####
#### Function: Bidirectional forecasting
#### 2018.12.23 Ushio
#### R 3.4.4
####

require(rEDM)

# Define function
bidirect_block_lnlp <- function(time_series,
                                complete_case_only = FALSE, # if TRUE, averaged predictions will be calculated only for complete pairs
                                lib = c(1, NROW(time_series)),
                                pred = lib,
                                tp_forward = 1,
                                tp_backward = -NCOL(time_series),
                                tau = 1,
                                theta = 8,
                                method = "s-map",
                                num_neighbors = 0,
                                stats_only = FALSE,
                                silent = TRUE,
                                exclusion_radius = NULL,
                                epsilon = NULL){
  # Perform forward and backward simplex projection
  pred_forward <- block_lnlp(time_series, tp = tp_forward, lib = c(1, NROW(time_series)), pred = lib, method = method, num_neighbors = num_neighbors, stats_only = F, silent = silent, theta = theta)
  pred_backward <- block_lnlp(time_series, tp = tp_backward, lib = c(1, NROW(time_series)), pred = lib, method = method, num_neighbors = num_neighbors, stats_only = F, silent = silent, theta = theta)
  
  # Match time indices of the model output
  time_shared <- as.numeric(na.omit(intersect(pred_forward$model_output[[1]]$time,
                                              pred_backward$model_output[[1]]$time)))
  # Extract model output
  time_forward <- pred_forward$model_output[[1]][match(time_shared, pred_forward$model_output[[1]]$time),]
  time_backward <- pred_backward$model_output[[1]][match(time_shared, pred_backward$model_output[[1]]$time),]
  
  # Averaging forward and backward predictions
  if(complete_case_only){
    averaged_prediction <- (time_forward$pred + time_backward$pred)/2
  }else{
    averaged_prediction <- apply(cbind(time_forward$pred, time_backward$pred), 1, function(x) mean(x, na.rm = T))
  }
  pred_bidirect <- data.frame(time = time_forward$time,
                              obs = time_forward$obs,
                              pred = averaged_prediction)
  
  # Collecting parameters
  params_forward <- pred_forward[1:16]
  params_backward <- pred_backward[1:16]
  params_all <- cbind(data.frame(method = c("forward_prediction","backward_prediction")),
                     rbind(params_forward, params_backward))
  
  # Calculate prediction accuracy
  stats_forward <- pred_forward[,c("num_pred", "rho", "mae", "rmse")]
  stats_backward <- pred_backward[,c("num_pred", "rho", "mae", "rmse")]
  stats_bidirection <- compute_stats(pred_bidirect$obs, pred_bidirect$pred)
  stats_all <- cbind(data.frame(method = c("bidirect_prediction","forward_prediction","backward_prediction")),
                     rbind(stats_bidirection, stats_forward, stats_backward))      

  # Return output
  if(stats_only){
    pred_bidirect_all <- data.frame(stats_all)
  }else{
    pred_bidirect_all <- list(params = params_all, model_output = pred_bidirect, stats = stats_all)
  }
  return(pred_bidirect_all)
}

compute_stats <- function(obs, pred){
  # computes performance metrics for how well predictions match observations
  # obs = vector of observations
  # pred = vector of prediction
  
  num_pred <- sum(is.finite(obs) & is.finite(pred))
  rho <- cor(obs, pred, use = "pairwise.complete.obs")
  mae <- mean(abs(obs-pred), na.rm = TRUE)
  rmse <- sqrt(mean((obs-pred)^2, na.rm = TRUE))
  return(data.frame(num_pred = num_pred, rho = rho, mae = mae, rmse = rmse))
}

# Calculate best E using bidirectional simplex projection
bestT_bidirect_block_lnlp <- function(time_series,
                                      theta_range = c(0, 1e-04, 3e-04,
                                                      0.001, 0.003, 0.01, 0.03,
                                                      0.1, 0.3, 0.5, 0.75,
                                                      1, 1.5, 2, 3, 4, 6, 8),
                                      lib = c(1, NROW(time_series)),
                                      tp_forward = 1,
                                      tp_backward = -NCOL(time_series),
                                      complete_case_only = F,
                                      criteria = "rmse",
                                      show_fig = F,
                                      save_stats = F){
  pred_res <- bidirect_block_lnlp(time_series, lib = lib, tp_forward = tp_forward, tp_backward = tp_backward, stats_only = T, complete_case_only = complete_case_only, theta = theta_range[1])[1,]
  for(i in 2:length(theta_range)) pred_res[i,] <- bidirect_block_lnlp(time_series, lib = lib, tp_forward = tp_forward, tp_backward = tp_backward, stats_only = T, complete_case_only = complete_case_only, theta = theta_range[i])[1,]
  best_T <- theta_range[which.min(pred_res[,criteria])]
  
  if(show_fig) plot(theta_range, pred_res[,criteria], type = "b", ylab = criteria, xlab = expression(theta)) 
  if(save_stats){
    all_res <- list(E = best_T, stats = pred_res)
  }else{
    all_res <- best_T
  }
  return(all_res)
}